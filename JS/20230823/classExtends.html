<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
</head>
<body>
    <script>
      // case1
      // class Factory {
      //     constructor(taste1, taste2) {
      //       this.taste1 = taste1;
      //       this.taste2 = taste2;
      //     }

      //     taste() {
      //       console.log(`${this.taste1}와 ${this.taste2} 맛이 난다!`);
      //     }
      //   }

      //   class FiresSausage extends Factory {
      //     fireTaste() {
      //       this.taste();
      //       console.log('불맛이 난다!');
      //     }
      //   }

      //   const sausage = new FiresSausage('소고기', '파');
      //   sausage.fireTaste();


        // case2
        class Sausage {
            constructor(item1, item2) {
              this.item1 = item1;
              this.item2 = item2;
              this.name = `${item1} ${item2} 소세지`;
            }

            taste() { // 부모 메서드
              console.log(
                `소세지에서 ${this.item1}와 ${this.item2}의 맛이 난다!`
              );
            }
          }

          // const sausage = new Sausage();

          // 소시지 클래스를 상속받는 FiresSausage 파생클래스를 생성해봅니다. 파생클래스의 taste 메서드를 실행하면 콘솔 메세지에 불맛이 나기 시작합니다.

          class FiresSausage extends Sausage {
            taste(msg) { // 자식 인스턴스에서 부모의 메서드(상위에 있는 taste())를 수정하여 구현 => 오버라이딩
              // 오버로딩 테크닉. 전달인자에 따라 다른 결과를 처리하도록 만들어 줍니다.
              if (msg) {
                console.log(
                  `소세지에서 불맛이 어우러진 ${this.item1}와 ${this.item2}의 맛이 난다!! ${msg} 때문인것 같다!`
                );
              } else {
                console.log(
                  `소세지에서 불맛이 어우러진 ${this.item1}와 ${this.item2}의 맛이 난다!!`
                );
              }
            }
          }

// const firesSausage = new FiresSausage('파', '계란');
    </script>
</body>
</html>