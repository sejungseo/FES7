<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
</head>
<body>
    <script>
      /**
       * 왜 객체지향 프로그래밍을 해야할까?
       * 1. 깔끔하고 이해하기 쉬운 코드를 짤 수 있다.
       * 2. 확장하기 쉬운 코드를 짤 수 있다.
       * 3. 유지보수 하기 쉬운 코드를 짤 수 있다.
       * 4. 메모리를 절약하는 코드를 짤 수 있다.
       *
       * 객체지향 프로그래밍이란? 데이터와 그것을 다루는 함수를 객체라는 하나의 장소에 모아둔 것
      */

      // 절차지향적 

      // let name = '뭉치',
      //     weapon = '검'

      // function attack() {
      //   return `${name}가 ${weapon}으로 공격합니다!`;
      // }

      // function changeWeapon() {
      //   weapon = '창';
      //   return `무기가 ${weapon}으로 교체되었습니다.`;
      // }

      // -------------------------------------------------

        // const knight = {
        //   name : '뭉치',
        //   weapon : '검',
        //   attack() {
        //     return `${this.name}가 ${this.weapon}으로 공격합니다!`
        //   },
        //   changeWeapon(newWeapon) {
        //     this.weapon = newWeapon;
        //     return `무기가 ${this.weapon}으로 교체되었습니다.`;
        //   }
        // };

        // const knight2 = {
        //   name : '넙치',
        //   weapon : '창',
        //   attack() {
        //     return `${this.name}가 ${this.weapon}으로 공격합니다!`
        //   },
        //   changeWeapon(newWeapon) {
        //     this.weapon = newWeapon;
        //     return `무기가 ${this.weapon}으로 교체되었습니다.`;
        //   }
        // };


        // encapsulation ==> 캡슐화한다. 
        // 데이터와 해당 데이터를 조작하는 메서드를 하나의 단위로 묶는 것
        // 코드의 가독성과 유지보수가 좋아짐

        // 위와 같은 방법은 두가지 문제가 있다.
        // 1. 객체가 필요할 때마다 새롭게 선언된다.
        //2. 똑같은 기능을 하는 함수가 반복되고 있다.

        //---------------------------------------
        // 프로토타입

        // function Knight(name, weapon) {
        //   this.name = name;
        //   this.weapon =weapon;
        // }
        
        // Knight.prototype.attack = function() {
        //   return `${this.name}가 ${this.weapon}으로 공격합니다!`
        // }
        
        // Knight.prototype.changeWeapon = function(newWeapon) {
        //   return `무기가 ${this.weapon = newWeapon}으로 교체되었습니다.`;
        // }

        //--------------------------------------------
        // class 문법
        // 쉽게 상속 받을 수 있음
        // 캡슐화 가능

        class BaseCharacter {
          constructor(name, weapon) {
            this.name = name;
            this.weapon = weapon;
          }

          attack() {
            return `${this.name}가 ${this.weapon}으로 공격합니다!`
          }

          changeWeapon(newWeapon) {
            this.weapon = newWeapon;
            return `무기가 ${this.weapon = newWeapon}으로 교체되었습니다.`;
          }
        }

        // const knight = new Knight('뭉치', '검');

        class Skeleton extends BaseCharacter {
          constructor(name, weapon, unitType) {
            super(name, weapon); 
            // 부모 클래스의 생성자 호출. constructor와 동일하게 생각
            this.unitType = unitType;
          }
        }

        const skeleton = new Skeleton('뭉치', '방패', '악마');

    </script>
</body>
</html>